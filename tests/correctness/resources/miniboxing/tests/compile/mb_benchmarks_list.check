Specializing class MBList...
  // interface:
  abstract trait MBList[T] extends Object {
    def contains$J(val T$TypeTag: Byte,e: T @storage[Long]): Boolean
    def contains(e: T): Boolean
    def length$J(val T$TypeTag: Byte): Int
    def length(): Int
    def toString2$J(val T$TypeTag: Byte): String
    def toString2(): String
    final private[this] def containsTail$J(val T$TypeTag: Byte,list: miniboxing.benchmarks.minibox.MBList[T],e: T @storage[Long]): Boolean
    final private[this] def containsTail(list: miniboxing.benchmarks.minibox.MBList[T],e: T): Boolean
    final private[this] def tailHash$J(val T$TypeTag: Byte,list: miniboxing.benchmarks.minibox.MBList[T],or: Int): Int
    final private[this] def tailHash(list: miniboxing.benchmarks.minibox.MBList[T],or: Int): Int
    override def hashCode$J(val T$TypeTag: Byte): Int
    override def hashCode(): Int
    override def toString$J(val T$TypeTag: Byte): String
    override def toString(): String
    val head$J(val T$TypeTag: Byte): T @storage[Long]
    val head(): T
    val tail$J(val T$TypeTag: Byte): miniboxing.benchmarks.minibox.MBList[T]
    val tail(): miniboxing.benchmarks.minibox.MBList[T]
  }
  // specialized class:
  class MBList$J[Tsp] extends MBList[Tsp] {
    def <init>(val miniboxing|benchmarks|minibox|MBList$J|T$TypeTag: Byte,head: Tsp @storage[Long],tail: miniboxing.benchmarks.minibox.MBList[Tsp]): miniboxing.benchmarks.minibox.MBList$J[Tsp] // is a specialized implementation of constructor MBList
    def contains$J(val T$TypeTag: Byte,e: Tsp @storage[Long]): Boolean     // is a specialized implementation of method contains
    def contains(e: Tsp): Boolean                                          // is a forwarder to the specialized member
    def length$J(val T$TypeTag: Byte): Int                                 // is a specialized implementation of method length
    def length(): Int                                                      // is a forwarder to the specialized member
    def toString2$J(val T$TypeTag: Byte): String                           // is a specialized implementation of method toString2
    def toString2(): String                                                // is a forwarder to the specialized member
    final private[this] def containsTail$J(val T$TypeTag: Byte,list: miniboxing.benchmarks.minibox.MBList[Tsp],e: Tsp @storage[Long]): Boolean // is a specialized implementation of method containsTail
    final private[this] def containsTail(list: miniboxing.benchmarks.minibox.MBList[Tsp],e: Tsp): Boolean // is a forwarder to the specialized member
    final private[this] def tailHash$J(val T$TypeTag: Byte,list: miniboxing.benchmarks.minibox.MBList[Tsp],or: Int): Int // is a specialized implementation of method tailHash
    final private[this] def tailHash(list: miniboxing.benchmarks.minibox.MBList[Tsp],or: Int): Int // is a forwarder to the specialized member
    override def hashCode$J(val T$TypeTag: Byte): Int                      // is a specialized implementation of method hashCode
    override def hashCode(): Int                                           // is a forwarder to the specialized member
    override def toString$J(val T$TypeTag: Byte): String                   // is a specialized implementation of method toString
    override def toString(): String                                        // is a forwarder to the specialized member
    private[this] val head: Tsp @storage[Long]                             // is a specialized implementation of value head
    private[this] val miniboxing|benchmarks|minibox|MBList$J|T$TypeTag: Byte // is a type tag
    private[this] val tail: miniboxing.benchmarks.minibox.MBList[Tsp]      // is a specialized implementation of value tail
    val head$J(val T$TypeTag: Byte): Tsp @storage[Long]                    // is a setter or getter for value head
    val head(): Tsp                                                        // is a forwarder to the specialized member
    val tail$J(val T$TypeTag: Byte): miniboxing.benchmarks.minibox.MBList[Tsp] // is a setter or getter for value tail
    val tail(): miniboxing.benchmarks.minibox.MBList[Tsp]                  // is a forwarder to the specialized member
  }
  // specialized class:
  class MBList$L[Tsp] extends MBList[Tsp] {
    def <init>(head: Tsp,tail: miniboxing.benchmarks.minibox.MBList[Tsp]): miniboxing.benchmarks.minibox.MBList$L[Tsp] // is a specialized implementation of constructor MBList
    def contains$J(val T$TypeTag: Byte,e: Tsp @storage[Long]): Boolean     // is a forwarder to the specialized member
    def contains(e: Tsp): Boolean                                          // is a specialized implementation of method contains
    def length$J(val T$TypeTag: Byte): Int                                 // is a forwarder to the specialized member
    def length(): Int                                                      // is a specialized implementation of method length
    def toString2$J(val T$TypeTag: Byte): String                           // is a forwarder to the specialized member
    def toString2(): String                                                // is a specialized implementation of method toString2
    final private[this] def containsTail$J(val T$TypeTag: Byte,list: miniboxing.benchmarks.minibox.MBList[Tsp],e: Tsp @storage[Long]): Boolean // is a forwarder to the specialized member
    final private[this] def containsTail(list: miniboxing.benchmarks.minibox.MBList[Tsp],e: Tsp): Boolean // is a specialized implementation of method containsTail
    final private[this] def tailHash$J(val T$TypeTag: Byte,list: miniboxing.benchmarks.minibox.MBList[Tsp],or: Int): Int // is a forwarder to the specialized member
    final private[this] def tailHash(list: miniboxing.benchmarks.minibox.MBList[Tsp],or: Int): Int // is a specialized implementation of method tailHash
    override def hashCode$J(val T$TypeTag: Byte): Int                      // is a forwarder to the specialized member
    override def hashCode(): Int                                           // is a specialized implementation of method hashCode
    override def toString$J(val T$TypeTag: Byte): String                   // is a forwarder to the specialized member
    override def toString(): String                                        // is a specialized implementation of method toString
    private[this] val head: Tsp                                            // is a specialized implementation of value head
    private[this] val tail: miniboxing.benchmarks.minibox.MBList[Tsp]      // is a specialized implementation of value tail
    val head$J(val T$TypeTag: Byte): Tsp @storage[Long]                    // is a forwarder to the specialized member
    val head(): Tsp                                                        // is a setter or getter for value head
    val tail$J(val T$TypeTag: Byte): miniboxing.benchmarks.minibox.MBList[Tsp] // is a forwarder to the specialized member
    val tail(): miniboxing.benchmarks.minibox.MBList[Tsp]                  // is a setter or getter for value tail
  }
[Now checking: minibox-inject]
[Now checking: minibox-bridge]
[Not checkable: minibox-coerce]
Miniboxing plugin warning: Optimizing `MbArray` is only possible if you allow the plugin to use both long and double encodings (remove `P:minibox:Yone-way` compiler option). `MbArray`-s will be generic and will box.
Miniboxing plugin warning: Optimizing `MbTuple` is only possible if you allow the plugin to use both long and double encodings (remove `P:minibox:Yone-way` compiler option). `MbTuple`-s will be generic and will box.
[[syntax trees at end of            minibox-commit]] // newSource1.scala
package miniboxing.benchmarks.minibox {
  abstract trait MBList[@miniboxed T] extends Object {
    <stable> <accessor> <paramaccessor> def head(): T;
    <stable> <accessor> def head$J(T$TypeTag: Byte): Long;
    <stable> <accessor> <paramaccessor> def tail(): miniboxing.benchmarks.minibox.MBList[T];
    <stable> <accessor> def tail$J(T$TypeTag: Byte): miniboxing.benchmarks.minibox.MBList[T];
    def length(): Int;
    def length$J(T$TypeTag: Byte): Int;
    override def toString(): String;
    override def toString$J(T$TypeTag: Byte): String;
    def contains(e: T): Boolean;
    def contains$J(T$TypeTag: Byte, e: Long): Boolean;
    override def hashCode(): Int;
    override def hashCode$J(T$TypeTag: Byte): Int;
    def toString2(): String;
    def toString2$J(T$TypeTag: Byte): String
  };
  class MBList$J[Tsp] extends Object with miniboxing.benchmarks.minibox.MBList[Tsp] {
    <paramaccessor> private[this] val miniboxing|benchmarks|minibox|MBList$J|T$TypeTag: Byte = _;
    <paramaccessor> private[this] val head: Long = _;
    <stable> <accessor> <paramaccessor> def head(): Tsp = MiniboxConversions.this.minibox2box[Tsp](MBList$J.this.head$J(MBList$J.this.miniboxing|benchmarks|minibox|MBList$J|T$TypeTag), MBList$J.this.miniboxing|benchmarks|minibox|MBList$J|T$TypeTag);
    <stable> <accessor> def head$J(T$TypeTag: Byte): Long = MBList$J.this.head;
    <paramaccessor> private[this] val tail: miniboxing.benchmarks.minibox.MBList[Tsp] = _;
    <stable> <accessor> <paramaccessor> def tail(): miniboxing.benchmarks.minibox.MBList[Tsp] = MBList$J.this.tail$J(MBList$J.this.miniboxing|benchmarks|minibox|MBList$J|T$TypeTag);
    <stable> <accessor> def tail$J(T$TypeTag: Byte): miniboxing.benchmarks.minibox.MBList[Tsp] = MBList$J.this.tail;
    def <init>(miniboxing|benchmarks|minibox|MBList$J|T$TypeTag: Byte, head: Long, tail: miniboxing.benchmarks.minibox.MBList[Tsp]): miniboxing.benchmarks.minibox.MBList$J[Tsp] = {
      MBList$J.super.<init>();
      ()
    };
    def length(): Int = MBList$J.this.length$J(MBList$J.this.miniboxing|benchmarks|minibox|MBList$J|T$TypeTag);
    def length$J(T$TypeTag: Byte): Int = 1.+(if (MBList$J.this.tail$J(T$TypeTag).!=(null))
      MBList$J.this.tail$J(T$TypeTag).length$J(T$TypeTag)
    else
      0);
    override def toString(): String = MBList$J.this.toString$J(MBList$J.this.miniboxing|benchmarks|minibox|MBList$J|T$TypeTag);
    override def toString$J(T$TypeTag: Byte): String = MiniboxDispatch.this.mboxed_toString(MBList$J.this.head$J(T$TypeTag), T$TypeTag).+(if (MBList$J.this.tail$J(T$TypeTag).!=(null))
      ", ".+(MBList$J.this.tail$J(T$TypeTag).toString$J(T$TypeTag))
    else
      "");
    final private[this] def containsTail(list: miniboxing.benchmarks.minibox.MBList[Tsp], e: Tsp): Boolean = MBList$J.this.containsTail$J(MBList$J.this.miniboxing|benchmarks|minibox|MBList$J|T$TypeTag, list, MiniboxConversions.this.box2minibox_tt[Tsp](e, MBList$J.this.miniboxing|benchmarks|minibox|MBList$J|T$TypeTag));
    final private[this] def containsTail$J(T$TypeTag: Byte, list: miniboxing.benchmarks.minibox.MBList[Tsp], e: Long): Boolean = if (MiniboxDispatch.this.mboxed_eqeq_notag(list.head$J(T$TypeTag), e))
      true
    else
      if (list.tail$J(T$TypeTag).==(null))
        false
      else
        MBList$J.this.containsTail$J(T$TypeTag, list.tail$J(T$TypeTag), e);
    def contains(e: Tsp): Boolean = MBList$J.this.contains$J(MBList$J.this.miniboxing|benchmarks|minibox|MBList$J|T$TypeTag, MiniboxConversions.this.box2minibox_tt[Tsp](e, MBList$J.this.miniboxing|benchmarks|minibox|MBList$J|T$TypeTag));
    def contains$J(T$TypeTag: Byte, e: Long): Boolean = MBList$J.this.containsTail$J(T$TypeTag, MBList$J.this, e);
    final private[this] def tailHash(list: miniboxing.benchmarks.minibox.MBList[Tsp], or: Int): Int = MBList$J.this.tailHash$J(MBList$J.this.miniboxing|benchmarks|minibox|MBList$J|T$TypeTag, list, or);
    final private[this] def tailHash$J(T$TypeTag: Byte, list: miniboxing.benchmarks.minibox.MBList[Tsp], or: Int): Int = {
      val headhash: Int = MiniboxDispatch.this.mboxed_hashCode(list.head$J(T$TypeTag), T$TypeTag);
      if (list.tail$J(T$TypeTag).==(null))
        headhash.|(or)
      else
        MBList$J.this.tailHash$J(T$TypeTag, list.tail$J(T$TypeTag), or.|(headhash.>>(8)))
    };
    override def hashCode(): Int = MBList$J.this.hashCode$J(MBList$J.this.miniboxing|benchmarks|minibox|MBList$J|T$TypeTag);
    override def hashCode$J(T$TypeTag: Byte): Int = MBList$J.this.tailHash$J(T$TypeTag, MBList$J.this, 0);
    def toString2(): String = MBList$J.this.toString2$J(MBList$J.this.miniboxing|benchmarks|minibox|MBList$J|T$TypeTag);
    def toString2$J(T$TypeTag: Byte): String = MBList$J.this.toString$J(T$TypeTag)
  };
  class MBList$L[Tsp] extends Object with miniboxing.benchmarks.minibox.MBList[Tsp] {
    <paramaccessor> private[this] val head: Tsp = _;
    <stable> <accessor> <paramaccessor> def head(): Tsp = MBList$L.this.head;
    <stable> <accessor> def head$J(T$TypeTag: Byte): Long = MiniboxConversions.this.box2minibox_tt[Tsp](MBList$L.this.head(), T$TypeTag);
    <paramaccessor> private[this] val tail: miniboxing.benchmarks.minibox.MBList[Tsp] = _;
    <stable> <accessor> <paramaccessor> def tail(): miniboxing.benchmarks.minibox.MBList[Tsp] = MBList$L.this.tail;
    <stable> <accessor> def tail$J(T$TypeTag: Byte): miniboxing.benchmarks.minibox.MBList[Tsp] = MBList$L.this.tail();
    def <init>(head: Tsp, tail: miniboxing.benchmarks.minibox.MBList[Tsp]): miniboxing.benchmarks.minibox.MBList$L[Tsp] = {
      MBList$L.super.<init>();
      ()
    };
    def length(): Int = 1.+(if (MBList$L.this.tail().!=(null))
      MBList$L.this.tail().length()
    else
      0);
    def length$J(T$TypeTag: Byte): Int = MBList$L.this.length();
    override def toString(): String = MBList$L.this.head().toString().+(if (MBList$L.this.tail().!=(null))
      ", ".+(MBList$L.this.tail().toString())
    else
      "");
    override def toString$J(T$TypeTag: Byte): String = MBList$L.this.toString();
    final private[this] def containsTail(list: miniboxing.benchmarks.minibox.MBList[Tsp], e: Tsp): Boolean = if (list.head().==(e))
      true
    else
      if (list.tail().==(null))
        false
      else
        MBList$L.this.containsTail(list.tail(), e);
    final private[this] def containsTail$J(T$TypeTag: Byte, list: miniboxing.benchmarks.minibox.MBList[Tsp], e: Long): Boolean = MBList$L.this.containsTail(list, MiniboxConversions.this.minibox2box[Tsp](e, T$TypeTag));
    def contains(e: Tsp): Boolean = MBList$L.this.containsTail(MBList$L.this, e);
    def contains$J(T$TypeTag: Byte, e: Long): Boolean = MBList$L.this.contains(MiniboxConversions.this.minibox2box[Tsp](e, T$TypeTag));
    final private[this] def tailHash(list: miniboxing.benchmarks.minibox.MBList[Tsp], or: Int): Int = {
      val headhash: Int = list.head().hashCode();
      if (list.tail().==(null))
        headhash.|(or)
      else
        MBList$L.this.tailHash(list.tail(), or.|(headhash.>>(8)))
    };
    final private[this] def tailHash$J(T$TypeTag: Byte, list: miniboxing.benchmarks.minibox.MBList[Tsp], or: Int): Int = MBList$L.this.tailHash(list, or);
    override def hashCode(): Int = MBList$L.this.tailHash(MBList$L.this, 0);
    override def hashCode$J(T$TypeTag: Byte): Int = MBList$L.this.hashCode();
    def toString2(): String = MBList$L.this.toString();
    def toString2$J(T$TypeTag: Byte): String = MBList$L.this.toString2()
  }
}
[Now checking: minibox-commit]